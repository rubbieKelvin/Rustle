COMMENT = _{ "#" ~ (!NEWLINE ~ ANY)* }
ESC     = _{ "\\" ~ ("\"" | "\\" | "n" | "t" | "r" | "b" | "f" | "u" ~ ASCII_HEX_DIGIT ~ ASCII_HEX_DIGIT ~ ASCII_HEX_DIGIT ~ ASCII_HEX_DIGIT) }

// ---
// Define basic whitespace components
HS = _{ " " | "\t" }
// Horizontal Space (silent)
NL = _{ NEWLINE }
// Newline (silent, using PEST's built-in NEWLINE)

// General WHITESPACE for implicit skipping by PEST in other parts of the grammar if needed
// However, for env_block, we'll be very explicit.
WHITESPACE = _{ HS | NL }
// Retain this for other rules or PEST's implicit skips

api_file = { SOI ~ (env_block | request_block | COMMENT | WHITESPACE)* ~ EOI }


// Identifier and Value String (seem okay, value_string captures up to a newline)
identifier   = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }
value_string =  { 
    "\"" ~ (ESC | !("\"" | "\\") ~ ANY)* ~ "\""  // Quoted string with escapes
    | (!NEWLINE ~ ANY)+  // Unquoted string
}
// Captures content on a line, stopping before NEWLINE

// Environment Variable (does NOT consume its own trailing newline directly)
// The newline will be handled by the list structure in env_block.
env_variable = { identifier ~ ("." ~ identifier)? ~ HS* ~ "=" ~ HS* ~ value_string }

// Environment Block with strict newline handling
env_block = {
    "@env" ~ HS* ~ NL // Rule 1: @env, optional trailing spaces, then mandatory NEWLINE.
  ~ (HS* ~ env_variable ~ HS* ~ NL)* // Rule 3: Zero or more variable lines.
  // Each variable line:
  // - HS*: Optional leading spaces (indentation).
  // - env_variable: The variable definition.
  // - HS*: Optional trailing spaces on the variable line.
  // - NL: Mandatory NEWLINE ending the variable line.
  ~ HS* ~ "@end" // Rule 2: @end starts on a new line (guaranteed by previous NL),
  // possibly with leading HS (indentation).
}

// ---

// Request Block
request_block = {
    "@request" ~ WHITESPACE+ ~ request_name ~ WHITESPACE+ ~ http_method ~ WHITESPACE+ ~ url_string ~ WHITESPACE* ~ config_section? ~ headers_section? ~ query_section? ~ body_section? ~ script_section? ~ WHITESPACE* ~ "@end"
}
request_name  = { identifier }
// no custom http methods, fuck you.
http_method = { "GET" | "POST" | "PUT" | "DELETE" | "PATCH" | "OPTIONS" | "HEAD" | "TRACE" | "CONNECT" }
url_string  = { value_string }
// Can contain {{vars}}

config_section  = { "@config" ~ WHITESPACE* ~ "{" ~ WHITESPACE* ~ config_property* ~ WHITESPACE* ~ "}" }
config_property = { identifier ~ WHITESPACE* ~ ":" ~ WHITESPACE* ~ config_value ~ ("," | WHITESPACE*)? }
// Simplified
config_value =  { array_value | string_value | number_value | boolean_value }
string_value = @{
    "\"" ~ (ESC | !("\"" | "\\") ~ ANY)* ~ "\""
  | // Quoted string with escapes
  (!("{" | "}" | "," | NEWLINE | WHITESPACE) ~ ANY)+
}
// Unquoted string (simple value)}
// Quoted or unquoted
number_value  = @{ "-"? ~ ASCII_DIGIT+ ~ ("." ~ ASCII_DIGIT+)? }
boolean_value = @{ "true" | "false" }
array_value   = @{ "[" ~ WHITESPACE* ~ (string_value ~ (WHITESPACE* ~ "," ~ WHITESPACE* ~ string_value)*)? ~ WHITESPACE* ~ "]" }

headers_section =  { "@headers" ~ WHITESPACE* ~ "{" ~ WHITESPACE* ~ header_line* ~ WHITESPACE* ~ "}" }
header_line     =  { header_name ~ WHITESPACE* ~ ":" ~ WHITESPACE* ~ header_value ~ WHITESPACE* }
header_name     = @{ (ASCII_ALPHANUMERIC | "-")+ }
header_value    =  { value_string }

query_section = { "@query" ~ WHITESPACE* ~ "{" ~ WHITESPACE* ~ query_param* ~ WHITESPACE* ~ "}" }
query_param   = { identifier ~ WHITESPACE* ~ ":" ~ WHITESPACE* ~ query_value ~ WHITESPACE* }
query_value   = { array_value | value_string }
// Simplified

body_section = {
    (body_json | body_graphql | body_multipart /* ... other types */
  )
}
body_json    = { "@body:json" ~ WHITESPACE* ~ json_content }
// json_content needs to correctly parse JSON structure or take raw block
json_content = { (json_object | json_array) }
// Simplified
json_object = _{ "{" ~ (pair ~ ("," ~ pair)*)? ~ "}" }
json_array  = _{ "[" ~ (json_value ~ ("," ~ json_value)*)? ~ "]" }
pair        = _{ string_value ~ ":" ~ json_value }
json_value  = _{ string_value | number_value | json_object | json_array | boolean_value | "null" }

body_graphql          = { "@body:graphql" ~ WHITESPACE* ~ graphql_query_content ~ (WHITESPACE* ~ graphql_variables_section)? }
graphql_query_content = { block_content }
// Content until next known directive or end
graphql_variables_section = { "@variables:json" ~ WHITESPACE* ~ json_content }

body_multipart  = { "@body:multipart" ~ WHITESPACE* ~ "{" ~ WHITESPACE* ~ multipart_entry* ~ WHITESPACE* ~ "}" }
multipart_entry = { multipart_field | multipart_file }
multipart_field = { "field" ~ WHITESPACE+ ~ string_value ~ WHITESPACE* ~ "=" ~ WHITESPACE* ~ string_value ~ WHITESPACE* }
multipart_file  = { "file" ~ WHITESPACE+ ~ string_value ~ WHITESPACE* ~ "=" ~ WHITESPACE* ~ string_value ~ (WHITESPACE+ ~ "type" ~ WHITESPACE+ ~ string_value)? ~ WHITESPACE* }

script_section = { "@script:post-request" ~ WHITESPACE* ~ "{" ~ script_content ~ "}" }
// script_content needs to capture everything, including nested braces, until the final closing brace of the script block.
// This is often done by matching balanced braces or taking raw content.
script_content = @{ ((!"}" ~ ANY) | ("}" ~ !"}"))* }
// Simplified: captures till first '}' - needs improvement for nested braces
// A better way for script_content or json_content is to parse balanced braces or use a dedicated parser for the embedded language.
// For now, `block_content` can be a rule that captures text more generally.
block_content = { ((!("@" | "}")) ~ ANY)+ }
// Very simplified rule for "take until next @ or }"

// Catch-all for anything not matching, useful for debugging grammar
// unknown_line = { (!NEWLINE ~ ANY)* ~ NEWLINE }
